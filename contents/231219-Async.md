# 🤿 Async: Intro.

이번 글에서는 비동기 및 비차단(non-blocking) 아키텍처에 대해 알아봅니다.<br>

이러한 아키텍처에 대한 Vapor의 접근 방식과 사용 방법을 알아볼 수 있습니다.<br>

마지막으로, 이 글에서는 Vapor에서 사용하는 핵심 기술인 SwiftNIO에 대한 간략한 개요를 제공합니다.<br>

# 🤿 Async: Async.

Vapor의 가장 중요한 기능 중 하나는 `비동기화(Async)`입니다.<br>

하지만 가장 혼란스러운 기능 중 하나이기도 합니다.<br>

왜 중요할까요?<br>

서버에 스레드가 하나만 있고 클라이언트 요청이 순서대로 네 개 있는 시나리오를 생각해보세요.<br>

1. 주식 시세 요청. 그러면 다른 서버의 API가 호출됩니다.
2. 정적 CSS 스타일시트에 대한 요청입니다. CSS는 조회 없이 즉시 사용할 수 있습니다.
3. 사용자 프로필에 대한 요청입니다. 프로필은 데이터베이스에서 가져와야 합니다.
4. 정적 HTML에 대한 요청입니다. HTML은 조회 없이 즉시 사용할 수 있습니다.

`동기식 서버(synchronous server)`에서는 주식 시세가 반환될 때까지 서버의 유일한 스레드가 차단됩니다.<br>

그런 다음 주식 시세와 CSS 스타일 시트를 반환합니다.<br>

`데이터베이스 가져오기(database fetch)`가 완료되는 동안 다시 `차단(block)`됩니다.<br>

그래야만 사용자 프로필이 전송된 후 서버가 정적 HTML을 클라이언트에 반환합니다.<br>

반면에 `비동기 서버(asynchronous server)`에서는 스레드가 주식 시세를 가져오기 위한 호출을 시작하고 요청이 완료될 때까지 요청을 보류합니다.<br>

그런 다음 CSS 스타일 시트를 반환하고 `데이터베이스 가져오기(database fetch)`를 시작하여 `정적 HTML(static HTML)`을 반환합니다.<br>

보류된 요청이 완료되면 스레드는 해당 요청에 대한 작업을 재개하고 그 결과를 클라이언트에 반환합니다.<br>

<img src = "https://github.com/devKobe24/images/blob/main/VDD-Async-1.png?raw=true"><br>

"하지만, 잠깐!", 당신은 말합니다.<br>

"서버에는 여러 개의 스레드가 있습니다."<br>

그 말이 맞습니다.<br>

하지만 서버가 가질 수 있는 스레드의 수에는 한계가 있습니다.<br>

스레드를 생성하는 것은 자원을 사용합니다.<br>

스레드 간의 컨텍스트 전환은 비용이 많이 들며, 모든 데이터 접근을 스레드 안전하게 유지하는 것은 시간이 많이 걸리고 오류가 발생하기 쉽습니다.<br>

그 결과, 스레드를 추가하는 것만으로 문제를 해결하려고 하는 것은 비효율적이고 나쁜 해결책입니다.<br>

## 🤿 Futures and promises.

응답을 기다리는 동안 요청은 "보류(put aside)"하기 위해서는, 응답을 받았을 때 그 작업을 재개할 수 있도록 **프로미스(promise)** 로 감싸야 합니다.<br>

실제로, 이는 보류 할 수 있는 메소드들의 반환 타입을 변경해야 한다는 것을 의미합니다.<br>

동기적 환경에서는 다음과 같은 메소드를 가질 수 있습니다.<br>

```swift
func getAllUsers() -> [User] {
    // do some database queries
}
```

비동기 환경에서는 이 방식이 작동하지 않습니다.<br>

왜냐하면 데이터베이스 호출이 `getAllUsers()`가 반환해야 할 시점에 완료되지 않았을 수 있기 때문입니다.<br>

미래에 `[User]`를 반환할 수 있을 것임을 알지만, 지금은 할 수 없습니다.<br>

Vapor에서는 결과를 **EventLoopFuture** 로 감싸서 반환합니다.<br>

이는 `SwiftNIO`의 `EventLoop`에 특화된 `미래(future)`입니다.<br>

아래와 같이 메소드를 작성하게 됩니다.<br>

```swift
func getAllUsers() -> EventLoopFuture<[User]> {
    // do some database queries
}
```

`EventLoopFuture<[User]>`를 반환함으로써, 그 시점에 반환할 것이 아무것도 없을지라도 메소드 호출자에게 무언가를 반환할 수 있습니다.<br>

하지만 호출자는 이 메소드가 미래의 어느 시점에 `[User]`를 반환한다는 것을 알고 있습니다.<br>

`SwiftNIO`에 대해 추후에 더 배우게 될 것입니다.<br>
